{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#ecodynamicsjl","title":"EcoDynamics.jl","text":"<p>EcoDynamics.jl is a Julia package for simulation of ecosystem processes, specifically population and community dynamics on spatial graphs. </p>"},{"location":"examples/community_inference/","title":"Bayesian Inference of community dynamics using Turing.jl","text":""},{"location":"examples/community_inference/#inferring-community-dynamics","title":"Inferring community dynamics","text":"<p>This use case shows how to build and run a model of community dynamics (the Rosenzweig-MacArthur model, specifically).</p> <pre><code>using MetacommunityDynamics\n</code></pre> <p>The Rosenzweig-MacArthur model is a model of consumer-resource dynamics. </p> <p>It is described by the equations </p> <p>$$ \\frac{dR}{dt} = \\lambda R \\bigg(1 - \\frac{R}{K}\\bigg) - \\frac{\\alpha CR}{1 +\\alpha \\eta R} $$</p> <p>$$ \\frac{dC}{dt} = \\frac{\\alpha CR}{1 + \\alpha \\eta R} - \\gamma   C $$</p> <p>where $R$ is the relative biomass of the resource, $C$ is the relative biomass of the consumer, $\\alpha$ is the attack-rate, $\\eta$ is the handling type, $\\lambda$ is the maximum instric growth rate,  $\\beta$ is the intrinsic infintesimal growth of biomass for the consumer per unit resource, and $\\gamma$ is the intrinsic death date of consumers. Note that this is equivalent to a Lotka-Volterra model with a Holling Type-II functional response. </p> <p>Let's simulate it ,using only 3 lines of Julia. </p> <p>First we build the model</p> <pre><code>rm = RosenzweigMacArthur()\n</code></pre> <pre><code>RosenzweigMacArthur{Int64, Float64}([0 1; 0 0], [0.0, 0.5], [0.0 5.0; 5.0 0.0], [0.0 3.0; 3.0 0.0], [0.0 0.5; 0.5 0.0], [0.1, 0.0], [0.0, 0.3])\n</code></pre> <p>Then we setup the problem</p> <pre><code>p = problem(rm, Deterministic)\n</code></pre> <pre><code>MetacommunityDynamics.Problem{SciMLBase.ODEProblem{Vector{Float64}, Tuple{Int64, Int64}, false, Vector{Array{Float64}}, SciMLBase.ODEFunction{false, SciMLBase.AutoSpecialize, MetacommunityDynamics.var\"#91#92\"{RosenzweigMacArthur{Int64, Float64}}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing}, Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, SciMLBase.StandardODEProblem}}(RosenzweigMacArthur{Int64, Float64}([0 1; 0 0], [0.0, 0.5], [0.0 5.0; 5.0 0.0], [0.0 3.0; 3.0 0.0], [0.0 0.5; 0.5 0.0], [0.1, 0.0], [0.0, 0.3]), SciMLBase.ODEProblem{Vector{Float64}, Tuple{Int64, Int64}, false, Vector{Array{Float64}}, SciMLBase.ODEFunction{false, SciMLBase.AutoSpecialize, MetacommunityDynamics.var\"#91#92\"{RosenzweigMacArthur{Int64, Float64}}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing}, Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, SciMLBase.StandardODEProblem}(SciMLBase.ODEFunction{false, SciMLBase.AutoSpecialize, MetacommunityDynamics.var\"#91#92\"{RosenzweigMacArthur{Int64, Float64}}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing}(MetacommunityDynamics.var\"#91#92\"{RosenzweigMacArthur{Int64, Float64}}(RosenzweigMacArthur{Int64, Float64}([0 1; 0 0], [0.0, 0.5], [0.0 5.0; 5.0 0.0], [0.0 3.0; 3.0 0.0], [0.0 0.5; 0.5 0.0], [0.1, 0.0], [0.0, 0.3])), LinearAlgebra.UniformScaling{Bool}(true), nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, SciMLBase.DEFAULT_OBSERVED, nothing, nothing), [0.2, 0.2], (0, 100), Array{Float64}[[0.0, 0.5], [0.0 5.0; 5.0 0.0], [0.0 3.0; 3.0 0.0], [0.0 0.5; 0.5 0.0], [0.1, 0.0], [0.0, 0.3]], Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}(), SciMLBase.StandardODEProblem()), (0, 100), [0.2, 0.2], missing)\n</code></pre> <p>Third we simulate!</p> <pre><code>traj = simulate(p)\n</code></pre> <pre><code>An trajectory of length 101.\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \n           0.250193 \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2860\u280a\u2809\u2809\u2809\u2809\u2809\u2813\u2812\u2824\u2884\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n                    \u2502\u2800\u2800\u2800\u2800\u28c0\u2824\u2824\u2824\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u285c\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2811\u2812\u2824\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n                    \u2502\u2800\u2864\u281a\u2809\u2800\u2800\u2800\u2800\u2800\u2811\u2884\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u287c\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2822\u28a4\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n                    \u2502\u2818\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2831\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2811\u2822\u28c0\u2800\u2800\u2800\u2800\u28c0\u2824\u2814\u2812\u2809\u2809\u2809\u2809\u2809\u2813\u2822\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n                    \u2502\u2800\u2818\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2831\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u284e\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2891\u28e2\u2852\u2809\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2811\u28a2\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n                    \u2502\u2800\u2800\u2831\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2860\u2834\u280a\u2801\u2800\u2811\u2822\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n                    \u2502\u2800\u2800\u2800\u2831\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2886\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2847\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2860\u2814\u2809\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2823\u2884\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n   Biomass          \u2502\u2800\u2800\u2800\u2800\u2818\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2823\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u2824\u2812\u2809\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2812\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n                    \u2502\u2800\u2800\u2800\u2800\u2800\u2818\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2811\u2884\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2847\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u2860\u2814\u280b\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2823\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n                    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u2884\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2822\u2840\u2800\u2800\u2800\u2800\u2800\u2878\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u2860\u2814\u280a\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2822\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n                    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2886\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2832\u28c0\u2840\u2800\u28a0\u2803\u2800\u2800\u2800\u2800\u2800\u2880\u2860\u2834\u2812\u2809\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2886\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n                    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2886\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2809\u2891\u281e\u2832\u2812\u2812\u2812\u2809\u2809\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u2822\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n                    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2831\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u280e\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2811\u2804\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n                    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2822\u2884\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u2824\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n                  0 \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2809\u2809\u2812\u2812\u2812\u2809\u2809\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502 \n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \n                    \u28000\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800110\u2800 \n                    \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800time (t)\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \n</code></pre> <pre><code>obs = observe(Observer(frequency=1), traj)\n</code></pre> <pre><code>2\u00d7101 Matrix{Float64}:\n 0.177111  0.229383  0.250658  0.19834   \u2026  0.160771   0.179864   0.159841\n 0.205403  0.178452  0.198924  0.192312     0.0563771  0.0444241  0.0145398\n</code></pre> <p></p> <p></p>"},{"location":"examples/community_inference/#inference","title":"Inference","text":"<p>First we define our model for inference.</p> <p>```@example 1 @model function fit_rm(data, prob)     \u03c3 ~ InverseGamma(2,3)     \u03bb ~ TruncatedNormal(0.5,1, 0,1.5)     \u03b1 ~ Normal(2,3.)     \u03b7 ~ Normal(2,3.)     \u03b2 ~ TruncatedNormal(0.5,1,0,1.5)     \u03b3 ~ TruncatedNormal(0.5,1,0,1.5)     K ~ TruncatedNormal(0.5,1,0,1.5)</p> <pre><code>\u03b8 = two_species(RosenzweigMacArthur, \u03bb=\u03bb, \u03b1=\u03b1, \u03b7=\u03b7, \u03b2=\u03b2, \u03b3=\u03b3, K=K)\npredicted = solve(prob, Tsit5(); p=\u03b8, saveat=1)\n\nfor i in eachindex(predicted)\n    data[:,i] ~ MvNormal(predicted[i], \u03c3^2 * I)\nend\n</code></pre> <p>end <code>Next we fit da model</code>@example 1 model = fit_rm(obs, prob.prob) chain = sample(model, NUTS(0.65), MCMCSerial(), 300, 1) posterior_samples = sample(chain[[:\u03bb, :\u03b1, :\u03b7, :\u03b2, :\u03b3, :K]], 300) ```</p> <p>and we plot plosterior samples with the original data</p> <p>```@example 1 f = Figure() ax = Axis(f[1,1], xlabel=\"Time\", ylabel=\"Biomass\") xlims!(0,100) for p in eachrow(Array(posterior_samples))     \u03bb, \u03b1, \u03b7, \u03b2, \u03b3, K =  p     \u03b8 = two_species(RosenzweigMacArthur, \u03bb=\u03bb, \u03b1=\u03b1, \u03b7=\u03b7, \u03b2=\u03b2, \u03b3=\u03b3, K=K)</p> <pre><code>sol_p = solve(prob.prob, Tsit5(); p=\u03b8, saveat=1)\n\nlines!(ax, sol_p.t, [sol_p.u[i][1] for i in eachindex(sol_p.t)], color=(:lightskyblue1, 0.1))\nlines!(ax, sol_p.t, [sol_p.u[i][2] for i in eachindex(sol_p.t)], color=(:lightcoral, 0.04))\n</code></pre> <p>end scatter!(ax, 1:size(obs,2), obs[1,:], color=(:dodgerblue)) scatter!(ax, 1:size(obs,2), obs[2,:], color=(:red, 0.5)) f ```</p>"},{"location":"getting_started/design/","title":"Package design","text":"<p>What is the type system?</p>"},{"location":"getting_started/hello_world/","title":"Hello World","text":""},{"location":"getting_started/hello_world/#hello-world-in-ecodynamicsjl","title":"Hello World in <code>EcoDynamics.jl</code>","text":"<p>Okay</p> <p><code>@example 1 sg = SpatialGraph()</code></p>"},{"location":"lib/internal/","title":"Internal","text":""},{"location":"lib/internal/#documentation-for-internal-methods","title":"Documentation for internal methods","text":"<p># <code>Base.size</code> \u2014 Method.</p> <pre><code>Base.size(sg::SpatialGraph)\n</code></pre> <p>Returns the number of nodes in a spatial graph <code>sg</code>.</p> <p>source</p> <p># <code>MetacommunityDynamics._env_from_layer</code> \u2014 Method.</p> <pre><code>_env_from_layer(coords, layer::EnvironmentLayer)\n</code></pre> <p>Returns the values in the layer at the given coordinates, given the bounding-box os the coordinates is the extent of the layer.</p> <p>source</p> <p># <code>MetacommunityDynamics.distance_matrix</code> \u2014 Method.</p> <pre><code>distance_matrix(sg::SpatialGraph; distance = Euclidean())\n</code></pre> <p>Returns a matrix of pairwise distances for all nodes in a <code>SpatialGraph</code>. The argument passed to <code>distance</code> must be of type <code>Distance</code> from <code>Distances.jl</code>.</p> <p>source</p> <p>&lt;a id='MetacommunityDynamics.\u2202u-Union{Tuple{T}, Tuple{BevertonHolt{T}, T}} where T&lt;:Number' href='#MetacommunityDynamics.\u2202u-Union{Tuple{T}, Tuple{BevertonHolt{T}, T}} where T&lt;:Number'&gt;# <code>MetacommunityDynamics.\u2202u</code> \u2014 Method.</p> <pre><code>\u2202u(bm::BevertonHolt, x)\n</code></pre> <p>Single time-step for the <code>BevertonHolt</code> model. </p> <p>source</p>"},{"location":"lib/public/","title":"Public","text":""},{"location":"lib/public/#public-methods","title":"Public methods","text":"<p># <code>MetacommunityDynamics.BevertonHolt</code> \u2014 Type.</p> <pre><code>BevertonHolt &lt;: Model\n</code></pre> <p>The Beverton-Holt model is a discrete-time, deterministic model of population dynamics. It is commonly interpreted as a discrete-time version of the logistic model.  </p> <p>source</p> <p># <code>MetacommunityDynamics.DispersalPotential</code> \u2014 Type.</p> <pre><code>DispersalPotential\n</code></pre> <p>A dispersal potential is a matrix that contains the pairwise  probability of dispersal between sites in an <code>AbstractSpace</code>.</p> <p>Note this is a doubly-stochastic matrix, meaning all rows  and columns sum to 0.  </p> <p>source</p> <p># <code>MetacommunityDynamics.EnvironmentLayer</code> \u2014 Type.</p> <pre><code>EnvironmentLayer{T}\n</code></pre> <p>An <code>EnvironmentalLayer</code> stores a raster representation of a single environmental variable inside a matrix.</p> <p>source</p> <p># <code>MetacommunityDynamics.EnvironmentLayer</code> \u2014 Method.</p> <pre><code>EnvironmentLayer(; generator = MidpointDisplacement(0.7), sz=(50,50))\n</code></pre> <p>Builds an <code>EnvironmentalLayer</code> with a <code>NeutralLandscapes</code> generator</p> <p>source</p> <p># <code>MetacommunityDynamics.RosenzweigMacArthur</code> \u2014 Type.</p> <pre><code>struct RosenzweigMacArthur{S,T&lt;:Number} &lt;: Model\n</code></pre> <p>source</p> <p># <code>MetacommunityDynamics.SpatialGraph</code> \u2014 Type.</p> <pre><code>SpatialGraph{T &lt;: Number}\n</code></pre> <p>A <code>SpatialGraph</code> consists of a set of nodes with coordinates and associated environmental variables for each node.</p> <p>Specific information about the edges in a <code>SpatialGraph</code> (which represent movement between nodes) is not stored here, as they tend to rely on species-specific parameters. As such, that are computed by combining a <code>SpatialGraph</code> with a  <code>DispersalKernel</code> to create a <code>DispersalPotential</code>.  </p> <p>source</p> <p>&lt;a id='MetacommunityDynamics.SpatialGraph-Tuple{E} where E&lt;:EnvironmentLayer' href='#MetacommunityDynamics.SpatialGraph-Tuple{E} where E&lt;:EnvironmentLayer'&gt;# <code>MetacommunityDynamics.SpatialGraph</code> \u2014 Method.</p> <pre><code>SpatialGraph(layer::E; coords = [(rand(), rand()) for _ = 1:20]) where E&lt;:EnvironmentLayer\n</code></pre> <p>Builds a <code>SpatialGraph</code> where the environmental variable is built from a single EnvironmentLayer, and optionally the set of coordinates can be passed as a keyword argument.</p> <p>source</p> <p># <code>MetacommunityDynamics.SpatialGraph</code> \u2014 Method.</p> <pre><code>SpatialGraph(n::Integer)\n</code></pre> <p>Builds a spatial graph with <code>n</code> nodes in it.</p> <p>source</p> <p># <code>MetacommunityDynamics.SpatialGraph</code> \u2014 Method.</p> <pre><code>SpatialGraph(n::Integer)\n</code></pre> <p>Builds a spatial graph for a given environment matrix. The environmental matrix should be a matrix where each column is the vector of environmental variables for each node.</p> <p>source</p> <p># <code>MetacommunityDynamics.SpatialGraph</code> \u2014 Method.</p> <pre><code>SpatialGraph(; coords = nothing, env = nothing)\n</code></pre> <p>Builds a <code>SpatialGraph</code>, where both the coordinates and the environmental variables can be passed as keyword arguments. The environmental matrix should be a matrix where each column is the vector of environmental variables for each node.</p> <p>source</p> <p>&lt;a id='MetacommunityDynamics.SpatialGraph-Union{Tuple{Vector{E}}, Tuple{E}} where E&lt;:EnvironmentLayer' href='#MetacommunityDynamics.SpatialGraph-Union{Tuple{Vector{E}}, Tuple{E}} where E&lt;:EnvironmentLayer'&gt;# <code>MetacommunityDynamics.SpatialGraph</code> \u2014 Method.</p> <pre><code>SpatialGraph(layers::Vector{E}; coords = [(rand(), rand()) for _ = 1:20]) where E&lt;:EnvironmentLayer\n</code></pre> <p>Builds a spatial graph with environmental variables passed as a vector of EnvironmentLayers, and optionally coordinates passed as a keyword argument. </p> <p>source</p> <p>&lt;a id='MetacommunityDynamics.SpatialGraph-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Tuple' href='#MetacommunityDynamics.SpatialGraph-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Tuple'&gt;# <code>MetacommunityDynamics.SpatialGraph</code> \u2014 Method.</p> <pre><code>SpatialGraph(coords::Vector{T}; num_envdims=5) where T&lt;:Tuple\n</code></pre> <p>Constructs a <code>SpatialGraph</code> from a set of coordinates <code>coords</code>, which is a vector of (x,y) pairs. Builds a random environment matrix, with the optional keyword argument <code>num_envdims</code> controlling the dimensionality of the envrionmental variables at each node. </p> <p>source</p> <p># <code>MetacommunityDynamics.SpeciesPool</code> \u2014 Type.</p> <pre><code>SpeciesPool{T&lt;:Number}\n</code></pre> <p>A <code>SpeciesPool</code> consists of a set of species and their corresponding traits. </p> <p>source</p> <p># <code>MetacommunityDynamics.Trajectory</code> \u2014 Type.</p> <pre><code>Trajectory{S&lt;:SciMLBase.AbstractTimeseriesSolution}\n</code></pre> <p>A trajectory is a single output for a <code>Problem</code>.  </p> <p>source</p> <p># <code>MetacommunityDynamics.envdims</code> \u2014 Method.</p> <pre><code>envdims(sg::SpatialGraph)\n</code></pre> <p>Returns the dimensionality of the environmental variable associated with each node in a <code>SpatialGraph</code> sg.</p> <p>source</p> <p># <code>MetacommunityDynamics.environment</code> \u2014 Method.</p> <pre><code>environment(sg::SpatialGraph)\n</code></pre> <p>Returns the matrix of environmental variables of a <code>SpatialGraph</code> <code>sg</code></p> <p>source</p> <p># <code>MetacommunityDynamics.factory</code> \u2014 Method.</p> <pre><code>factory(bh::BevertonHolt)\n</code></pre> <p>Model factory for the Beverton-Holt model. Returns a function that takes a state <code>u</code> and returns an anonymous function and returns <code>du</code>. </p> <p>source</p> <p># <code>MetacommunityDynamics.numsites</code> \u2014 Method.</p> <pre><code>numsites(sg::SpatialGraph)\n</code></pre> <p>Returns the number of nodes in a <code>SpatialGraph</code> <code>sg</code>. </p> <p>source</p>"},{"location":"reference/community/overview/","title":"Overview","text":""},{"location":"reference/community/overview/#community-dynamics-in-ecodynamicsjl","title":"Community Dynamics in EcoDynamics.jl","text":"<p>The dynamics of ecological communities has a rich history. </p>"},{"location":"reference/metapopulation/overview/","title":"Overview","text":""},{"location":"reference/metapopulation/overview/#metapopulation-dynamics-in-ecodynamicsjl","title":"Metapopulation Dynamics in EcoDynamics.jl","text":"<p>Metapopulation dynamics refers to the set of theory describing the behavior of occupancy dynamics in a set of patches. </p>"},{"location":"reference/population/overview/","title":"Overview","text":""},{"location":"reference/population/overview/#population-dynamics-in-ecodynamicsjl","title":"Population Dynamics in EcoDynamics.jl","text":""}]}