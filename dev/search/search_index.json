{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#ecodynamicsjl","title":"EcoDynamics.jl","text":"<p>EcoDynamics.jl is a Julia package for simulation of ecosystem processes, specifically population and community dynamics on spatial graphs. </p>"},{"location":"examples/community_inference/","title":"Bayesian Inference of community dynamics using Turing.jl","text":""},{"location":"examples/community_inference/#inferring-community-dynamics","title":"Inferring community dynamics","text":"<p>This use case shows how to build and run a model of community dynamics (the Rosenzweig-MacArthur model, specifically).</p> <pre><code>using Turing, DiffEqBayes\nusing DifferentialEquations\nusing MetacommunityDynamics\nusing LinearAlgebra\nusing CairoMakie\n</code></pre> <pre><code>\u250c Warning: Environment variable CMDSTAN_HOME not set. Use set_cmdstan_home!.\n\u2514 @ StanBase ~/.julia/packages/StanBase/EKgLz/src/StanBase.jl:52\n</code></pre> <p>The Rosenzweig-MacArthur model is a model of consumer-resource dynamics. </p> <p>It is described by the equations </p> <p>$$ \\frac{dR}{dt} = \\lambda R \\bigg(1 - \\frac{R}{K}\\bigg) - \\frac{\\alpha CR}{1 +\\alpha \\eta R} $$</p> <p>$$ \\frac{dC}{dt} = \\frac{\\alpha CR}{1 + \\alpha \\eta R} - \\gamma   C $$</p> <p>where $R$ is the relative biomass of the resource, $C$ is the relative biomass of the consumer, $\\alpha$ is the attack-rate, $\\eta$ is the handling type, $\\lambda$ is the maximum instric growth rate,  $\\beta$ is the intrinsic infintesimal growth of biomass for the consumer per unit resource, and $\\gamma$ is the intrinsic death date of consumers. Note that this is equivalent to a Lotka-Volterra model with a Holling Type-II functional response. </p> <p>Let's simulate it ,using only 3 lines of Julia. </p> <p>First we build the model</p> <p>```@example rm = RosenzweigMacArthur() <pre><code>Then we setup the problem\n\n\n```@example\np = problem(rm, Deterministic)\n</code></pre></p> <p>Third we simulate!</p> <p>```@example traj = simulate(p) <pre><code>```@example\nobs = observe(Observer(frequency=1), traj)\n</code></pre></p> <p></p> <p></p>"},{"location":"examples/community_inference/#inference","title":"Inference","text":"<p>First we define our model for inference.</p> <p>```@example @model function fit_rm(data, prob)     \u03c3 ~ InverseGamma(2,3)     \u03bb ~ TruncatedNormal(0.5,1, 0,1.5)     \u03b1 ~ Normal(2,3.)     \u03b7 ~ Normal(2,3.)     \u03b2 ~ TruncatedNormal(0.5,1,0,1.5)     \u03b3 ~ TruncatedNormal(0.5,1,0,1.5)     K ~ TruncatedNormal(0.5,1,0,1.5)</p> <pre><code>\u03b8 = two_species(RosenzweigMacArthur, \u03bb=\u03bb, \u03b1=\u03b1, \u03b7=\u03b7, \u03b2=\u03b2, \u03b3=\u03b3, K=K)\npredicted = solve(prob, Tsit5(); p=\u03b8, saveat=1)\n\nfor i in eachindex(predicted)\n    data[:,i] ~ MvNormal(predicted[i], \u03c3^2 * I)\nend\n</code></pre> <p>end <code>Next we fit da model.</code>@example model = fit_rm(obs, prob.prob) chain = sample(model, NUTS(0.65), MCMCSerial(), 300, 1) posterior_samples = sample(chain[[:\u03bb, :\u03b1, :\u03b7, :\u03b2, :\u03b3, :K]], 300) ```</p> <p>and we plot plosterior samples with the original data:</p> <p>```@example f = Figure() ax = Axis(f[1,1], xlabel=\"Time\", ylabel=\"Biomass\") xlims!(0,100) for p in eachrow(Array(posterior_samples))     \u03bb, \u03b1, \u03b7, \u03b2, \u03b3, K =  p     \u03b8 = two_species(RosenzweigMacArthur, \u03bb=\u03bb, \u03b1=\u03b1, \u03b7=\u03b7, \u03b2=\u03b2, \u03b3=\u03b3, K=K)</p> <pre><code>sol_p = solve(prob.prob, Tsit5(); p=\u03b8, saveat=1)\n\nlines!(ax, sol_p.t, [sol_p.u[i][1] for i in eachindex(sol_p.t)], color=(:lightskyblue1, 0.1))\nlines!(ax, sol_p.t, [sol_p.u[i][2] for i in eachindex(sol_p.t)], color=(:lightcoral, 0.04))\n</code></pre> <p>end scatter!(ax, 1:size(obs,2), obs[1,:], color=(:dodgerblue)) scatter!(ax, 1:size(obs,2), obs[2,:], color=(:red, 0.5)) f ```</p>"},{"location":"getting_started/design/","title":"Package design","text":"<p>What is the type system?</p>"},{"location":"getting_started/hello_world/","title":"Hello World","text":""},{"location":"getting_started/hello_world/#hello-world-in-ecodynamicsjl","title":"Hello World in <code>EcoDynamics.jl</code>","text":"<p>Okay</p> <pre><code>using MetacommunityDynamics\nsg = SpatialGraph()\n</code></pre> <pre><code>A spatial graph with 20 locations.\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   1\u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u26ac\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2502\n    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n    \u2502\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u26ac\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n    \u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n   0\u2502\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u28000\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28001\u2800\n</code></pre>"},{"location":"lib/internal/","title":"Internal","text":""},{"location":"lib/internal/#documentation-for-internal-methods","title":"Documentation for internal methods","text":"<p># <code>Base.size</code> \u2014 Method.</p> <pre><code>Base.size(sg::SpatialGraph)\n</code></pre> <p>Returns the number of nodes in a spatial graph <code>sg</code>.</p> <p>source</p> <p># <code>MetacommunityDynamics._env_from_layer</code> \u2014 Method.</p> <pre><code>_env_from_layer(coords, layer::EnvironmentLayer)\n</code></pre> <p>Returns the values in the layer at the given coordinates, given the bounding-box os the coordinates is the extent of the layer.</p> <p>source</p> <p># <code>MetacommunityDynamics.distance_matrix</code> \u2014 Method.</p> <pre><code>distance_matrix(sg::SpatialGraph; distance = Euclidean())\n</code></pre> <p>Returns a matrix of pairwise distances for all nodes in a <code>SpatialGraph</code>. The argument passed to <code>distance</code> must be of type <code>Distance</code> from <code>Distances.jl</code>.</p> <p>source</p> <p>&lt;a id='MetacommunityDynamics.\u2202u-Union{Tuple{T}, Tuple{BevertonHolt{T}, T}} where T&lt;:Number' href='#MetacommunityDynamics.\u2202u-Union{Tuple{T}, Tuple{BevertonHolt{T}, T}} where T&lt;:Number'&gt;# <code>MetacommunityDynamics.\u2202u</code> \u2014 Method.</p> <pre><code>\u2202u(bm::BevertonHolt, x)\n</code></pre> <p>Single time-step for the <code>BevertonHolt</code> model. </p> <p>source</p>"},{"location":"lib/public/","title":"Public","text":""},{"location":"lib/public/#public-methods","title":"Public methods","text":"<p># <code>MetacommunityDynamics.BevertonHolt</code> \u2014 Type.</p> <pre><code>BevertonHolt &lt;: Model\n</code></pre> <p>The Beverton-Holt model is a discrete-time, deterministic model of population dynamics. It is commonly interpreted as a discrete-time version of the logistic model.</p> <p>It is described by </p> <p>$N_{t+1} =\\frac{R_0 M}{N_t + M}N_t$</p> <p>where $K = (R_0 - 1)M$ is the carrying capacity.</p> <p>source</p> <p># <code>MetacommunityDynamics.DispersalPotential</code> \u2014 Type.</p> <pre><code>DispersalPotential\n</code></pre> <p>A dispersal potential is a matrix that contains the pairwise  probability of dispersal between sites in an <code>AbstractSpace</code>.</p> <p>Note this is a doubly-stochastic matrix, meaning all rows  and columns sum to 0.  </p> <p>source</p> <p># <code>MetacommunityDynamics.EnvironmentLayer</code> \u2014 Type.</p> <pre><code>EnvironmentLayer{T}\n</code></pre> <p>An <code>EnvironmentalLayer</code> stores a raster representation of a single environmental variable inside a matrix.</p> <p>source</p> <p># <code>MetacommunityDynamics.EnvironmentLayer</code> \u2014 Method.</p> <pre><code>EnvironmentLayer(; generator = MidpointDisplacement(0.7), sz=(50,50))\n</code></pre> <p>Builds an <code>EnvironmentalLayer</code> with a <code>NeutralLandscapes</code> generator</p> <p>source</p> <p># <code>MetacommunityDynamics.RosenzweigMacArthur</code> \u2014 Type.</p> <pre><code>struct RosenzweigMacArthur{S,T&lt;:Number} &lt;: Model\n\n\nDynamics given by\n\n``\\frac{dR}{dt} = \\lambda R \\bigg(1 - \\frac{R}{K}\\bigg) - \\frac{\\alpha CR}{1 +\\alpha \\eta R}``\n``\\frac{dC}{dt} = \\frac{\\alpha CR}{1 + \\alpha \\eta R} - \\gamma   C``\n</code></pre> <p>source</p> <p># <code>MetacommunityDynamics.SpatialGraph</code> \u2014 Type.</p> <pre><code>SpatialGraph{T &lt;: Number}\n</code></pre> <p>A <code>SpatialGraph</code> consists of a set of nodes with coordinates and associated environmental variables for each node.</p> <p>Specific information about the edges in a <code>SpatialGraph</code> (which represent movement between nodes) is not stored here, as they tend to rely on species-specific parameters. As such, that are computed by combining a <code>SpatialGraph</code> with a  <code>DispersalKernel</code> to create a <code>DispersalPotential</code>.  </p> <p>source</p> <p>&lt;a id='MetacommunityDynamics.SpatialGraph-Tuple{E} where E&lt;:EnvironmentLayer' href='#MetacommunityDynamics.SpatialGraph-Tuple{E} where E&lt;:EnvironmentLayer'&gt;# <code>MetacommunityDynamics.SpatialGraph</code> \u2014 Method.</p> <pre><code>SpatialGraph(layer::E; coords = [(rand(), rand()) for _ = 1:20]) where E&lt;:EnvironmentLayer\n</code></pre> <p>Builds a <code>SpatialGraph</code> where the environmental variable is built from a single EnvironmentLayer, and optionally the set of coordinates can be passed as a keyword argument.</p> <p>source</p> <p># <code>MetacommunityDynamics.SpatialGraph</code> \u2014 Method.</p> <pre><code>SpatialGraph(n::Integer)\n</code></pre> <p>Builds a spatial graph with <code>n</code> nodes in it.</p> <p>source</p> <p># <code>MetacommunityDynamics.SpatialGraph</code> \u2014 Method.</p> <pre><code>SpatialGraph(n::Integer)\n</code></pre> <p>Builds a spatial graph for a given environment matrix. The environmental matrix should be a matrix where each column is the vector of environmental variables for each node.</p> <p>source</p> <p># <code>MetacommunityDynamics.SpatialGraph</code> \u2014 Method.</p> <pre><code>SpatialGraph(; coords = nothing, env = nothing)\n</code></pre> <p>Builds a <code>SpatialGraph</code>, where both the coordinates and the environmental variables can be passed as keyword arguments. The environmental matrix should be a matrix where each column is the vector of environmental variables for each node.</p> <p>source</p> <p>&lt;a id='MetacommunityDynamics.SpatialGraph-Union{Tuple{Vector{E}}, Tuple{E}} where E&lt;:EnvironmentLayer' href='#MetacommunityDynamics.SpatialGraph-Union{Tuple{Vector{E}}, Tuple{E}} where E&lt;:EnvironmentLayer'&gt;# <code>MetacommunityDynamics.SpatialGraph</code> \u2014 Method.</p> <pre><code>SpatialGraph(layers::Vector{E}; coords = [(rand(), rand()) for _ = 1:20]) where E&lt;:EnvironmentLayer\n</code></pre> <p>Builds a spatial graph with environmental variables passed as a vector of EnvironmentLayers, and optionally coordinates passed as a keyword argument. </p> <p>source</p> <p>&lt;a id='MetacommunityDynamics.SpatialGraph-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Tuple' href='#MetacommunityDynamics.SpatialGraph-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Tuple'&gt;# <code>MetacommunityDynamics.SpatialGraph</code> \u2014 Method.</p> <pre><code>SpatialGraph(coords::Vector{T}; num_envdims=5) where T&lt;:Tuple\n</code></pre> <p>Constructs a <code>SpatialGraph</code> from a set of coordinates <code>coords</code>, which is a vector of (x,y) pairs. Builds a random environment matrix, with the optional keyword argument <code>num_envdims</code> controlling the dimensionality of the envrionmental variables at each node. </p> <p>source</p> <p># <code>MetacommunityDynamics.SpeciesPool</code> \u2014 Type.</p> <pre><code>SpeciesPool{T&lt;:Number}\n</code></pre> <p>A <code>SpeciesPool</code> consists of a set of species and their corresponding traits. </p> <p>source</p> <p># <code>MetacommunityDynamics.Trajectory</code> \u2014 Type.</p> <pre><code>Trajectory{S&lt;:SciMLBase.AbstractTimeseriesSolution}\n</code></pre> <p>A trajectory is a single output for a <code>Problem</code>.  </p> <p>source</p> <p># <code>MetacommunityDynamics.envdims</code> \u2014 Method.</p> <pre><code>envdims(sg::SpatialGraph)\n</code></pre> <p>Returns the dimensionality of the environmental variable associated with each node in a <code>SpatialGraph</code> sg.</p> <p>source</p> <p># <code>MetacommunityDynamics.environment</code> \u2014 Method.</p> <pre><code>environment(sg::SpatialGraph)\n</code></pre> <p>Returns the matrix of environmental variables of a <code>SpatialGraph</code> <code>sg</code></p> <p>source</p> <p># <code>MetacommunityDynamics.factory</code> \u2014 Method.</p> <pre><code>factory(bh::BevertonHolt)\n</code></pre> <p>Model factory for the Beverton-Holt model. Returns a function that takes a state <code>u</code> and returns an anonymous function and returns <code>du</code>. </p> <p>source</p> <p># <code>MetacommunityDynamics.numsites</code> \u2014 Method.</p> <pre><code>numsites(sg::SpatialGraph)\n</code></pre> <p>Returns the number of nodes in a <code>SpatialGraph</code> <code>sg</code>. </p> <p>source</p>"},{"location":"model_index/community/overview/","title":"Overview","text":""},{"location":"model_index/community/overview/#community-dynamics-in-ecodynamicsjl","title":"Community Dynamics in EcoDynamics.jl","text":"<p>The dynamics of ecological communities has a rich history. </p>"},{"location":"model_index/metapopulation/overview/","title":"Overview","text":""},{"location":"model_index/metapopulation/overview/#metapopulation-dynamics-in-ecodynamicsjl","title":"Metapopulation Dynamics in EcoDynamics.jl","text":"<p>Metapopulation dynamics refers to the set of theory describing the behavior of occupancy dynamics in a set of patches. </p>"},{"location":"model_index/population/overview/","title":"Overview","text":""},{"location":"model_index/population/overview/#population-dynamics-in-ecodynamicsjl","title":"Population Dynamics in EcoDynamics.jl","text":""},{"location":"model_index/population/overview/#beverton-holt","title":"Beverton-Holt","text":""}]}